<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rowan Vale - Software Consultant | Beyond The Vale</title>
    <meta name="description" content="Home of a software engineering consultant showcasing scalable architectures, digital transformation initiatives, and full-stack solutions that drive modern enterprise growth.">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="logo">
                <a href="index.html">BEYOND THE VALE</a>
            </div>
            <ul class="nav-menu">
                <li class="nav-item"><a href="index.html" class="nav-link active">Home</a></li>
                <li class="nav-item"><a href="about.html" class="nav-link">About</a></li>
                <li class="nav-item"><a href="projects.html" class="nav-link">Projects</a></li>
                <li class="nav-item"><a href="contact.html" class="nav-link">Contact</a></li>
            </ul>
            <button class="hamburger" type="button" aria-label="Toggle navigation menu" aria-expanded="false">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </button>
        </div>
    </nav>

    <main class="main-content">
        <section class="hero">
            <h1>What You See Is Only the Surface</h1>
            <p class="hero-tagline">The best software architecture is invisible &mdash; until it isn't. I engineer the systems beneath: scalable, resilient, built to outlast the trends that spawned them.</p>
            <p class="hero-sub">Software Engineer &middot; Architect &middot; Boise, ID</p>
            <a href="projects.html" class="btn">Step Beyond</a>
        </section>

        <section class="content mt-xlarge">
            <a href="projects/simulations.html" class="sim-card" id="simCard">
                <canvas id="simCanvas"></canvas>
                <div class="sim-label" id="simLabel"></div>
            </a>
        </section>

        <section class="content mt-xlarge">
            <div class="card">
                <h2>Technical Proficiency</h2>
                <p>Specializing in full-stack development, cloud architecture, and intuitive UI design. Explore how I translate complex problems into elegant code.</p>
                <a href="about.html" class="btn-small">Learn More About My Process</a>
            </div>
        </section>
    </main>

    <footer class="footer">
        <p>&copy; 2026 Beyond The Vale. Built with precision and intent.</p>
    </footer>

    <script src="script.js"></script>
    <script>
    (function() {
        const canvas = document.getElementById('simCanvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const label = document.getElementById('simLabel');
        const CELL = 6;
        const sims = ['life', 'astar', 'sort'];
        const sim = sims[Math.floor(Math.random() * sims.length)];

        function resize() {
            const card = document.getElementById('simCard');
            const w = card.clientWidth;
            const cols = Math.floor(w / CELL);
            const rows = Math.floor(220 / CELL);
            canvas.width = cols * CELL;
            canvas.height = rows * CELL;
            return { cols, rows };
        }

        if (sim === 'life') {
            label.textContent = "Conway's Game of Life";
            const { cols, rows } = resize();
            let front = new Uint8Array(cols * rows);
            let back = new Uint8Array(cols * rows);
            for (let i = 0; i < front.length; i++) front[i] = Math.random() < 0.3 ? 1 : 0;
            function step() {
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        let n = 0;
                        for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) {
                            if (!dx && !dy) continue;
                            n += front[((y + dy + rows) % rows) * cols + ((x + dx + cols) % cols)];
                        }
                        const i = y * cols + x;
                        back[i] = (front[i] && (n === 2 || n === 3)) || (!front[i] && n === 3) ? 1 : 0;
                    }
                }
                [front, back] = [back, front];
            }
            function draw() {
                ctx.fillStyle = '#010604';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#c5a059';
                for (let y = 0; y < rows; y++)
                    for (let x = 0; x < cols; x++)
                        if (front[y * cols + x])
                            ctx.fillRect(x * CELL + 1, y * CELL + 1, CELL - 1, CELL - 1);
            }
            draw();
            setInterval(function() { step(); draw(); }, 100);

        } else if (sim === 'astar') {
            label.textContent = 'A* Pathfinding';
            const { cols, rows } = resize();
            const grid = new Uint8Array(cols * rows);
            const start = { x: 1, y: 1 }, end = { x: cols - 2, y: rows - 2 };
            for (let i = 0; i < grid.length; i++) grid[i] = Math.random() < 0.28 ? 1 : 0;
            grid[start.y * cols + start.x] = 0;
            grid[end.y * cols + end.x] = 0;
            for (let x = 0; x < cols; x++) grid[Math.floor(rows / 2) * cols + x] = Math.random() < 0.15 ? 1 : 0;
            for (let y = 0; y < rows; y++) grid[y * cols + Math.floor(cols / 2)] = Math.random() < 0.15 ? 1 : 0;
            const openSet = [start], closedSet = new Set(), cameFrom = new Map(), gScore = new Map(), fScore = new Map();
            let pathCells = new Set(), done = false;
            const k = (x, y) => y * cols + x;
            const hFn = (a, b) => Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));
            gScore.set(k(start.x, start.y), 0);
            fScore.set(k(start.x, start.y), hFn(start, end));
            function passable(px, py) { return px >= 0 && px < cols && py >= 0 && py < rows && grid[py * cols + px] !== 1; }
            function neighbors(node) {
                const r = [], x = node.x, y = node.y;
                const up = passable(x, y-1), dn = passable(x, y+1), lt = passable(x-1, y), rt = passable(x+1, y);
                if (up) r.push({x,y:y-1}); if (dn) r.push({x,y:y+1});
                if (lt) r.push({x:x-1,y}); if (rt) r.push({x:x+1,y});
                if (up && lt && passable(x-1,y-1)) r.push({x:x-1,y:y-1});
                if (up && rt && passable(x+1,y-1)) r.push({x:x+1,y:y-1});
                if (dn && lt && passable(x-1,y+1)) r.push({x:x-1,y:y+1});
                if (dn && rt && passable(x+1,y+1)) r.push({x:x+1,y:y+1});
                return r;
            }
            function stepSearch() {
                if (done || openSet.length === 0) return false;
                let bi = 0, bf = fScore.get(k(openSet[0].x, openSet[0].y)) || Infinity;
                for (let i = 1; i < openSet.length; i++) {
                    const f = fScore.get(k(openSet[i].x, openSet[i].y)) || Infinity;
                    if (f < bf) { bf = f; bi = i; }
                }
                const cur = openSet[bi], ck = k(cur.x, cur.y);
                if (cur.x === end.x && cur.y === end.y) {
                    done = true;
                    let t = ck; while (t !== undefined) { pathCells.add(t); t = cameFrom.get(t); }
                    return false;
                }
                openSet.splice(bi, 1); closedSet.add(ck);
                for (const nb of neighbors(cur)) {
                    const nk = k(nb.x, nb.y);
                    if (closedSet.has(nk)) continue;
                    const isDiag = nb.x !== cur.x && nb.y !== cur.y;
                    const tg = (gScore.get(ck) || 0) + (isDiag ? 1.414 : 1);
                    const pg = gScore.get(nk);
                    if (pg === undefined || tg < pg) {
                        cameFrom.set(nk, ck); gScore.set(nk, tg);
                        fScore.set(nk, tg + hFn(nb, end));
                        if (!openSet.some(n => k(n.x, n.y) === nk)) openSet.push(nb);
                    }
                }
                return openSet.length > 0;
            }
            function draw() {
                ctx.fillStyle = '#010604';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                for (let y = 0; y < rows; y++) for (let x = 0; x < cols; x++) {
                    const ky = k(x, y); let c = null;
                    if (x === start.x && y === start.y) c = '#c5a059';
                    else if (x === end.x && y === end.y) c = '#f3e5ab';
                    else if (pathCells.has(ky)) c = '#c5a059';
                    else if (grid[ky] === 1) c = '#033526';
                    else if (closedSet.has(ky)) c = '#310049';
                    else if (openSet.some(n => k(n.x, n.y) === ky)) c = '#1a0a2e';
                    if (c) { ctx.fillStyle = c; ctx.fillRect(x * CELL + 1, y * CELL + 1, CELL - 1, CELL - 1); }
                }
            }
            draw();
            const iv = setInterval(function() {
                for (let i = 0; i < 3; i++) { if (!stepSearch()) { clearInterval(iv); break; } }
                draw();
            }, 30);

        } else {
            // Sorting algorithm visualization
            const algoNames = ['Merge Sort', 'Quick Sort', 'Heap Sort', 'Shell Sort'];
            const pick = Math.floor(Math.random() * algoNames.length);
            label.textContent = algoNames[pick];
            const card = document.getElementById('simCard');
            const W = card.clientWidth;
            const H = 220;
            canvas.width = W; canvas.height = H;
            const n = Math.max(60, Math.floor(W / 4));
            const arr = [];
            for (let i = 1; i <= n; i++) arr.push(i);
            for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; }

            const queue = [];
            let highlight = { compare: [], swap: [], sorted: new Set() };
            // Save shuffled state; generators mutate arr for correct logic, then we restore for playback
            const saved = arr.slice();

            function enq(type, indices, vals) { queue.push({ type, indices, vals }); }

            function genMerge() {
                function ms(lo, hi) {
                    if (hi - lo <= 1) return;
                    const mid = (lo + hi) >> 1; ms(lo, mid); ms(mid, hi); mg(lo, mid, hi);
                }
                function mg(lo, mid, hi) {
                    const tmp = arr.slice(lo, hi);
                    let i = 0, j = mid - lo, k = lo;
                    while (i < mid - lo && j < hi - lo) {
                        enq('c', [lo + i, lo + j]);
                        if (tmp[i] <= tmp[j]) { arr[k] = tmp[i]; enq('s', [k], [tmp[i]]); i++; }
                        else { arr[k] = tmp[j]; enq('s', [k], [tmp[j]]); j++; }
                        k++;
                    }
                    while (i < mid - lo) { arr[k] = tmp[i]; enq('s', [k], [tmp[i]]); i++; k++; }
                    while (j < hi - lo) { arr[k] = tmp[j]; enq('s', [k], [tmp[j]]); j++; k++; }
                }
                ms(0, arr.length);
            }
            function genQuick() {
                function qs(lo, hi) {
                    if (lo >= hi) { if (lo === hi) enq('d', [lo]); return; }
                    const pivot = arr[hi]; let i = lo;
                    for (let j = lo; j < hi; j++) {
                        enq('c', [j, hi]);
                        if (arr[j] < pivot) {
                            enq('w', [i, j]);
                            [arr[i], arr[j]] = [arr[j], arr[i]];
                            i++;
                        }
                    }
                    enq('w', [i, hi]);
                    [arr[i], arr[hi]] = [arr[hi], arr[i]];
                    enq('d', [i]); qs(lo, i - 1); qs(i + 1, hi);
                }
                qs(0, arr.length - 1);
            }
            function genHeap() {
                const len = arr.length;
                function hf(sz, i) {
                    let lg = i, l = 2*i+1, r = 2*i+2;
                    enq('c', [l < sz ? l : i, i]);
                    if (l < sz && arr[l] > arr[lg]) lg = l;
                    enq('c', [r < sz ? r : i, lg]);
                    if (r < sz && arr[r] > arr[lg]) lg = r;
                    if (lg !== i) {
                        enq('w', [i, lg]);
                        [arr[i], arr[lg]] = [arr[lg], arr[i]];
                        hf(sz, lg);
                    }
                }
                for (let i = (len>>1)-1; i >= 0; i--) hf(len, i);
                for (let i = len-1; i > 0; i--) {
                    enq('w', [0, i]);
                    [arr[0], arr[i]] = [arr[i], arr[0]];
                    enq('d', [i]); hf(i, 0);
                }
                enq('d', [0]);
            }
            function genShell() {
                const len = arr.length;
                for (let gap = len >> 1; gap > 0; gap >>= 1) {
                    for (let i = gap; i < len; i++) {
                        const tmp = arr[i]; let j = i;
                        if (j >= gap) enq('c', [j, j - gap]);
                        while (j >= gap && arr[j - gap] > tmp) {
                            arr[j] = arr[j - gap];
                            enq('w', [j, j - gap]);
                            j -= gap;
                            if (j >= gap) enq('c', [j, j - gap]);
                        }
                        arr[j] = tmp;
                        enq('s', [j], [tmp]);
                    }
                }
            }

            [genMerge, genQuick, genHeap, genShell][pick]();
            // Restore shuffled array for playback
            for (let i = 0; i < arr.length; i++) arr[i] = saved[i];

            function draw() {
                ctx.fillStyle = '#010604';
                ctx.fillRect(0, 0, W, H);
                const bw = W / arr.length;
                for (let i = 0; i < arr.length; i++) {
                    const bh = (arr[i] / n) * (H - 4);
                    let color = '#c5a059';
                    if (highlight.sorted.has(i)) color = '#033526';
                    if (highlight.compare.includes(i)) color = '#f3e5ab';
                    if (highlight.swap.includes(i)) color = '#4b0082';
                    ctx.fillStyle = color;
                    ctx.fillRect(i * bw + 0.5, H - bh, Math.max(bw - 1, 1), bh);
                }
            }

            draw();
            const stepsPerFrame = Math.max(1, Math.floor(queue.length / 300));
            const iv = setInterval(function() {
                for (let s = 0; s < stepsPerFrame && queue.length > 0; s++) {
                    const op = queue.shift();
                    if (op.type === 'c') { highlight.compare = op.indices; highlight.swap = []; }
                    else if (op.type === 'w') {
                        highlight.swap = op.indices; highlight.compare = [];
                        const a = op.indices[0], b = op.indices[1];
                        [arr[a], arr[b]] = [arr[b], arr[a]];
                    }
                    else if (op.type === 's') { arr[op.indices[0]] = op.vals[0]; }
                    else if (op.type === 'd') { for (const i of op.indices) highlight.sorted.add(i); }
                }
                if (queue.length === 0) {
                    highlight.compare = []; highlight.swap = [];
                    for (let i = 0; i < arr.length; i++) highlight.sorted.add(i);
                    clearInterval(iv);
                }
                draw();
            }, 16);
        }
    })();
    </script>
</body>
</html>